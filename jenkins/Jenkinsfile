pipeline {
  agent any

  options {
    timestamps()
    disableConcurrentBuilds()
  }

  environment {
    TF_IN_AUTOMATION   = 'true'
    TF_INPUT           = 'false'
    TF_CLI_ARGS        = '-no-color'
    AWS_DEFAULT_REGION = 'ap-southeast-1'

    PLAN_OUT_PATH  = 'tfplan.bin'
    PLAN_JSON_PATH = 'tfplan.json'

    // These will come from Jenkins credentials / job config,
    // NOT hardcoded values.
    // Create "Secret text" credentials in Jenkins with ID "tf_state_bucket"
    // and "tf_state_key" storing bucket name and key.
    S3_STATE_BUCKET = credentials('tf_state_bucket')
    S3_STATE_KEY    = credentials('tf_state_key')

    // Optional: separate plan bucket/key; or reuse state bucket/key prefix.
    S3_PLAN_BUCKET = credentials('tf_plan_bucket')
    S3_PLAN_PREFIX = 'plans/dev'
  }

  stages {
    stage('Checkout') {
      steps { checkout scm }
    }

    stage('Terraform init') {
      steps {
        dir('envs/dev') {
          sh """
            cat > backend.hcl <<EOF
bucket = "${S3_STATE_BUCKET}"
key    = "${S3_STATE_KEY}"
region = "${AWS_DEFAULT_REGION}"
encrypt = true
EOF
            terraform init -backend-config=backend.hcl
          """
        }
      }
    }

    stage('Terraform fmt & validate') {
      steps {
        dir('envs/dev') {
          sh 'terraform fmt -check'
          sh 'terraform validate'
        }
      }
    }

    stage('Plan') {
      steps {
        dir('envs/dev') {
          sh 'terraform plan -out=$PLAN_OUT_PATH -var-file=dev.tfvars'
          sh 'terraform show -json $PLAN_OUT_PATH > $PLAN_JSON_PATH'
        }
      }
      post {
        success {
          dir('envs/dev') {
            sh 'aws s3 cp $PLAN_OUT_PATH s3://$S3_PLAN_BUCKET/$S3_PLAN_PREFIX/${BUILD_NUMBER}.tfplan'
            sh 'aws s3 cp $PLAN_JSON_PATH s3://$S3_PLAN_BUCKET/$S3_PLAN_PREFIX/${BUILD_NUMBER}.json'
            archiveArtifacts artifacts: "tfplan.bin, tfplan.json", fingerprint: true
          }
        }
      }
    }

    stage('Approve Apply') {
      steps {
        input message: 'Apply this Terraform plan to dev?', ok: 'Apply'
      }
    }

    stage('Apply') {
      steps {
        dir('envs/dev') {
          sh 'terraform apply -auto-approve $PLAN_OUT_PATH'
        }
      }
    }
  }

  post {
    always {
      dir('envs/dev') {
        sh 'rm -f $PLAN_OUT_PATH $PLAN_JSON_PATH backend.hcl || true'
      }
    }
  }
}
